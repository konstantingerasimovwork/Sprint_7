{"name": "Проверка логина курьера в системе без password", "status": "broken", "statusDetails": {"message": "requests.exceptions.ReadTimeout: HTTPSConnectionPool(host='qa-scooter.praktikum-services.ru', port=443): Read timed out. (read timeout=10)", "trace": "self = <urllib3.connectionpool.HTTPSConnectionPool object at 0x10e72cc90>, conn = <urllib3.connection.HTTPSConnection object at 0x110810d10>, method = 'POST', url = '/api/v1/courier/login'\ntimeout = Timeout(connect=10, read=10, total=None), chunked = False\nhttplib_request_kw = {'body': 'login=stnjaochga', 'headers': {'User-Agent': 'python-requests/2.28.2', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '16', 'Content-Type': 'application/x-www-form-urlencoded'}}\ntimeout_obj = Timeout(connect=10, read=10, total=None), read_timeout = 10\n\n    def _make_request(\n        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw\n    ):\n        \"\"\"\n        Perform a request on a given urllib connection object taken from our\n        pool.\n    \n        :param conn:\n            a connection from one of our connection pools\n    \n        :param timeout:\n            Socket timeout in seconds for the request. This can be a\n            float or integer, which will set the same timeout value for\n            the socket connect and the socket read, or an instance of\n            :class:`urllib3.util.Timeout`, which gives you more fine-grained\n            control over your timeouts.\n        \"\"\"\n        self.num_requests += 1\n    \n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = timeout_obj.connect_timeout\n    \n        # Trigger any extra validation we need to do.\n        try:\n            self._validate_conn(conn)\n        except (SocketTimeout, BaseSSLError) as e:\n            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n    \n        # conn.request() calls http.client.*.request, not the method in\n        # urllib3.request. It also calls makefile (recv) on the socket.\n        try:\n            if chunked:\n                conn.request_chunked(method, url, **httplib_request_kw)\n            else:\n                conn.request(method, url, **httplib_request_kw)\n    \n        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is\n        # legitimately able to close the connection after sending a valid response.\n        # With this behaviour, the received response is still readable.\n        except BrokenPipeError:\n            # Python 3\n            pass\n        except IOError as e:\n            # Python 2 and macOS/Linux\n            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS\n            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/\n            if e.errno not in {\n                errno.EPIPE,\n                errno.ESHUTDOWN,\n                errno.EPROTOTYPE,\n            }:\n                raise\n    \n        # Reset the timeout for the recv() on the socket\n        read_timeout = timeout_obj.read_timeout\n    \n        # App Engine doesn't have a sock attr\n        if getattr(conn, \"sock\", None):\n            # In Python 3 socket.py will catch EAGAIN and return None when you\n            # try and read into the file pointer created by http.client, which\n            # instead raises a BadStatusLine exception. Instead of catching\n            # the exception and assuming all BadStatusLine exceptions are read\n            # timeouts, check for a zero timeout before making the request.\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, \"Read timed out. (read timeout=%s)\" % read_timeout\n                )\n            if read_timeout is Timeout.DEFAULT_TIMEOUT:\n                conn.sock.settimeout(socket.getdefaulttimeout())\n            else:  # None or a value\n                conn.sock.settimeout(read_timeout)\n    \n        # Receive the response from the server\n        try:\n            try:\n                # Python 2.7, use buffering of HTTP responses\n                httplib_response = conn.getresponse(buffering=True)\n            except TypeError:\n                # Python 3\n                try:\n                    httplib_response = conn.getresponse()\n                except BaseException as e:\n                    # Remove the TypeError from the exception chain in\n                    # Python 3 (including for exceptions like SystemExit).\n                    # Otherwise it looks like a bug in the code.\n>                   six.raise_from(e, None)\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/connectionpool.py:449: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/connectionpool.py:444: in _make_request\n    httplib_response = conn.getresponse()\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/http/client.py:1375: in getresponse\n    response.begin()\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/http/client.py:318: in begin\n    version, status, reason = self._read_status()\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/http/client.py:279: in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/socket.py:706: in readinto\n    return self._sock.recv_into(b)\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/ssl.py:1278: in recv_into\n    return self.read(nbytes, buffer)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ssl.SSLSocket [closed] fd=-1, family=2, type=1, proto=0>, len = 8192, buffer = <memory at 0x110832080>\n\n    def read(self, len=1024, buffer=None):\n        \"\"\"Read up to LEN bytes and return them.\n        Return zero-length string on EOF.\"\"\"\n    \n        self._checkClosed()\n        if self._sslobj is None:\n            raise ValueError(\"Read on closed or unwrapped SSL socket.\")\n        try:\n            if buffer is not None:\n>               return self._sslobj.read(len, buffer)\nE               TimeoutError: The read operation timed out\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/ssl.py:1134: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <requests.adapters.HTTPAdapter object at 0x10e72d390>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=10, read=10, total=None), verify = True, cert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n>               resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout,\n                )\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/adapters.py:489: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/connectionpool.py:787: in urlopen\n    retries = retries.increment(\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/util/retry.py:550: in increment\n    raise six.reraise(type(error), error, _stacktrace)\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/packages/six.py:770: in reraise\n    raise value\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/connectionpool.py:703: in urlopen\n    httplib_response = self._make_request(\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/connectionpool.py:451: in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.connectionpool.HTTPSConnectionPool object at 0x10e72cc90>, err = TimeoutError('The read operation timed out'), url = '/api/v1/courier/login', timeout_value = 10\n\n    def _raise_timeout(self, err, url, timeout_value):\n        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"\n    \n        if isinstance(err, SocketTimeout):\n>           raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\nE           urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='qa-scooter.praktikum-services.ru', port=443): Read timed out. (read timeout=10)\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/urllib3/connectionpool.py:340: ReadTimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_courier.test_login_courier.TestLoginCourier object at 0x10e4ad810>, register_new_courier_and_return_login_password = ['stnjaochga', 'nzkkltwgtj', 'tqxxqhvwch']\n\n    @allure.title('Проверка логина курьера в системе без password')\n    @allure.description('BUG: Приходит 504 ошибка')\n    def test_get_error_without_password(self, register_new_courier_and_return_login_password):\n        payload = {\n            \"login\": register_new_courier_and_return_login_password[0]\n        }\n>       self.login_courier.post_request(payload)\n\ntests/test_courier/test_login_courier.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nendpoints/courier/login_courier.py:14: in post_request\n    self.response = requests.post(\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/api.py:115: in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/api.py:59: in request\n    return session.request(method=method, url=url, **kwargs)\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/sessions.py:587: in request\n    resp = self.send(prep, **send_kwargs)\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/sessions.py:701: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <requests.adapters.HTTPAdapter object at 0x10e72d390>, request = <PreparedRequest [POST]>, stream = False, timeout = Timeout(connect=10, read=10, total=None), verify = True, cert = None, proxies = OrderedDict()\n\n    def send(\n        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None\n    ):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(\n            request,\n            stream=stream,\n            timeout=timeout,\n            verify=verify,\n            cert=cert,\n            proxies=proxies,\n        )\n    \n        chunked = not (request.body is None or \"Content-Length\" in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError:\n                raise ValueError(\n                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"\n                    f\"or a single float to set both timeouts to the same value.\"\n                )\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout,\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, \"proxy_pool\"):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\n    \n                try:\n                    skip_host = \"Host\" in request.headers\n                    low_conn.putrequest(\n                        request.method,\n                        url,\n                        skip_accept_encoding=True,\n                        skip_host=skip_host,\n                    )\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n                    for i in request.body:\n                        low_conn.send(hex(len(i))[2:].encode(\"utf-8\"))\n                        low_conn.send(b\"\\r\\n\")\n                        low_conn.send(i)\n                        low_conn.send(b\"\\r\\n\")\n                    low_conn.send(b\"0\\r\\n\\r\\n\")\n    \n                    # Receive the response from the server\n                    r = low_conn.getresponse()\n    \n                    resp = HTTPResponse.from_httplib(\n                        r,\n                        pool=conn,\n                        connection=low_conn,\n                        preload_content=False,\n                        decode_content=False,\n                    )\n                except Exception:\n                    # If we hit any problems here, clean up the connection.\n                    # Then, raise so that we can handle the actual exception.\n                    low_conn.close()\n                    raise\n    \n        except (ProtocolError, OSError) as err:\n            raise ConnectionError(err, request=request)\n    \n        except MaxRetryError as e:\n            if isinstance(e.reason, ConnectTimeoutError):\n                # TODO: Remove this in 3.0.0: see #2811\n                if not isinstance(e.reason, NewConnectionError):\n                    raise ConnectTimeout(e, request=request)\n    \n            if isinstance(e.reason, ResponseError):\n                raise RetryError(e, request=request)\n    \n            if isinstance(e.reason, _ProxyError):\n                raise ProxyError(e, request=request)\n    \n            if isinstance(e.reason, _SSLError):\n                # This branch is for urllib3 v1.22 and later.\n                raise SSLError(e, request=request)\n    \n            raise ConnectionError(e, request=request)\n    \n        except ClosedPoolError as e:\n            raise ConnectionError(e, request=request)\n    \n        except _ProxyError as e:\n            raise ProxyError(e)\n    \n        except (_SSLError, _HTTPError) as e:\n            if isinstance(e, _SSLError):\n                # This branch is for urllib3 versions earlier than v1.22\n                raise SSLError(e, request=request)\n            elif isinstance(e, ReadTimeoutError):\n>               raise ReadTimeout(e, request=request)\nE               requests.exceptions.ReadTimeout: HTTPSConnectionPool(host='qa-scooter.praktikum-services.ru', port=443): Read timed out. (read timeout=10)\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/adapters.py:578: ReadTimeout"}, "description": "BUG: Приходит 504 ошибка", "steps": [{"name": "Логин курьера в системе", "status": "broken", "statusDetails": {"message": "requests.exceptions.ReadTimeout: HTTPSConnectionPool(host='qa-scooter.praktikum-services.ru', port=443): Read timed out. (read timeout=10)\n", "trace": "  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/allure_commons/_allure.py\", line 192, in impl\n    return func(*a, **kw)\n           ^^^^^^^^^^^^^^\n  File \"/Users/macbook/Desktop/Python/prakticum_python/Sprint_7/endpoints/courier/login_courier.py\", line 14, in post_request\n    self.response = requests.post(\n                    ^^^^^^^^^^^^^^\n  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/sessions.py\", line 587, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/sessions.py\", line 701, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/requests/adapters.py\", line 578, in send\n    raise ReadTimeout(e, request=request)\n"}, "parameters": [{"name": "payload", "value": "{'login': 'stnjaochga'}"}], "start": 1710008477972, "stop": 1710008488106}], "start": 1710008477972, "stop": 1710008488119, "uuid": "61eea6a4-e53a-4a50-9e6a-c1b39b0d4f95", "historyId": "56bcc19a820ea4f356e12aa7296d354b", "testCaseId": "56bcc19a820ea4f356e12aa7296d354b", "fullName": "tests.test_courier.test_login_courier.TestLoginCourier#test_get_error_without_password", "labels": [{"name": "parentSuite", "value": "tests.test_courier"}, {"name": "suite", "value": "test_login_courier"}, {"name": "subSuite", "value": "TestLoginCourier"}, {"name": "host", "value": "MBP-MacbookPro"}, {"name": "thread", "value": "5607-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_courier.test_login_courier"}]}